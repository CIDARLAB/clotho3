[
    {
        "schema":"Function",
        "id":"523e3b4cc2e6967acacb1723",
        "dependencies":["523e36e1c2e647abe23c1fa6"],
        "args":[{"type":"string","name":"sequence"}],
        "name":"PCRModuleTest",
        "code":"function(frags) { return PCR.ligate(frags); };","language":"JAVASCRIPT",
        "tests":[{"args":[["aaaaaaaaaaA^CATG_", "^CATG_Tttggttggttgg"]],"output":{"value":"aaaaaaaaaaACATGTttggttggttgg","type":"VALUE"}}]
    },
    {"schema": "Module", "name": "PCR", "language": "JAVASCRIPT", "dependencies":["523e36e1c2e647abe23c1fa5", "523e36e1c2e647abe23c1fa4"], "id": "523e36e1c2e647abe23c1fa6", "code" : "(function pcr_module() {\n/*************\n     Classes\n     ************/\n\n    //note - assumes only terminal ends -- run through parse first\n    function Fragment (markedSeq) {\n        /* checks */\n        //already a fragment - just pull the sequence and reprocess\n        if (markedSeq instanceof Fragment) {\n            markedSeq = markedSeq.sequence;\n        }\n        //nonterminal marks --- shouldn't be passed in...\n        if ((Digest.findOverhangs(markedSeq, true)).length) {\n            //future - how to handle?\n        }\n\n        this.sequence = markedSeq;\n        this.process();\n    }\n\n    Fragment.prototype = {\n\n        /**** prototype ****/\n\n        process : function(newSequence) {\n            if (!!newSequence)\n                this.sequence = newSequence;\n            this.ends = Digest.findOverhangs(this.sequence);\n            this.endMatches = _.pluck(this.ends, 'match');\n        },\n        reverse : function() {\n            this.sequence = DNA.revcomp(this.sequence);\n            this.process()\n        },\n        circularize : function() {\n            if (this.endMatches.length == 2 && this.endsMatch(this.endMatches[0], this.endMatches[1])) {\n                //remove end marks -- remove last overhang to circularize, and remove cut marks in first terminal cut\n\n                //remove last overhang\n                this.sequence = this.sequence.substring(0, this.sequence.length - this.endMatches[1].length);\n                //remove first cut marks, don't remove in whole sequence\n                this.sequence = this.ends[0].overhang + this.sequence.substring(this.endMatches[0].length);\n                this.process();\n            }\n        },\n\n        /**** basic matching ****/\n\n        //check that ends are complementary\n        endsMatch : function(match1, match2) {\n            return (match1 == match2 || match1 == DNA.revcomp(match2))\n        },\n        //only checks revcomp match\n        endsMatchRevcomp : function (match1, match2) {\n            return match1 == DNA.revcomp(match2)\n        },\n\n        /************\n        matching\n        ***********/\n\n        /***** match string ****/\n\n        //given match, returns array of ends in this that match\n        findMatchingEnds : function(match) {\n            return _.filter(this.ends, function(end, index) {\n                return this.endsMatch(end.match, match);\n            }, this);\n        },\n        //given match, returns array of indices of ends in this that match\n        findMatchingEndIndices : function(match) {\n            var endsMatching = this.findMatchingEnds(match);\n\n            switch (endsMatching.length) {\n                case 0 : {\n                    return false;\n                }\n                case 1 : {\n                    return [_.indexOf(this.ends, endsMatching[0])]\n                }\n                default : {\n                    //because assume <= 2 ends per fragment\n                    return [0,1];\n                }\n            }\n        },\n        //given match, whether fragment has a matching end in this fragment\n        //can also pass in fragment, defers to canMatchFrag\n        canMatch : function (match) {\n            if (match instanceof Fragment) {\n                return this.canMatchFrag(match)\n            } else {\n                return !!(this.findMatchingEnds(match)).length;\n            }\n        },\n\n        /**** match fragment ****/\n\n        canMatchFrag : function (otherFrag) {\n            return !!(_.find(otherFrag.endMatches, function (otherMatch) {\n                return this.canMatch(otherMatch);\n            }, this) || []).length;\n        },\n\n        //return object of ends which match: keys = this.ends index, values = otherFrag\n        matchMap : function (otherFrag) {\n            var connections = {};\n            _.each(this.endMatches, function (thisMatch, thisInd) {\n                _.each(otherFrag.endMatches, function (otherMatch, otherInd) {\n                    if (this.endsMatch(thisMatch, otherMatch)) {\n                        if (!connections[thisInd])\n                            connections[thisInd] = otherInd;\n                        else {\n                            //points to two fragments\n                            //future - handle this\n                            console.log('pointing to two fragments');\n                        }\n                    }\n                }, this)\n            }, this);\n\n            if (!_.keys(connections).length) return undefined;\n            return connections\n        },\n\n        /*** match array of fragments***/\n\n        matchMapArray : function(otherFrags) {\n\n            //don't introduce return inconsistency\n            /*\n            if (otherFrags.length == 1) {\n                return this.matchMap(otherFrags[0])\n            } else if (otherFrags instanceof Fragment) {\n                return this.matchMap(otherFrags)\n            }\n            */\n\n            var matchMap = {};\n            _.each(otherFrags, function(frag, index) {\n                if (this !== frag)\n                    matchMap[index] = this.matchMap(frag);\n            }, this);\n            return matchMap;\n        },\n        findFirstMatch : function (otherFrags) {\n            return _.find(otherFrags, function(otherFrag, index) {\n                //this !== otherFrag && console.log(this, otherFrag); //testing\n                return ((this !== otherFrag) && (this.canMatch(otherFrag)))\n            }, this)\n        },\n        findFirstMatchIndex : function (otherFrags) {\n            return _.indexOf(otherFrags, this.findFirstMatch(otherFrags));\n        },\n        canMatchArray : function (otherFrags) {\n            return !!this.findFirstMatch(otherFrags)\n        },\n\n        /*** joining ***/\n\n        joinFragment : function(otherFrag) {\n            if (_.isString(otherFrag))\n                otherFrag = new Fragment(otherFrag);\n\n            var connections = this.matchMap(otherFrag);\n\n            if (!_.keys(connections).length)\n                return false;\n\n            //find connection\n            //for now just pull the first connection\n            //future - check for unique matches\n            var firstConnection = _.pairs(connections)[0],\n                thisEndInd = firstConnection[0],\n                otherEndInd = firstConnection[1],\n                thisEnd = this.ends[thisEndInd],\n                otherEnd = otherFrag.ends[otherEndInd];\n            \n            //console.log('joinFragment - this end and other end:', thisEnd, otherEnd);\n\n            //console.log('before orienting', thisEndInd, otherEndInd);\n\n\n            //todo - own function, standard return to avoid all these variables\n            //orient fragments\n            //can assume terminal, so just need to make sure one is zero\n            if (thisEnd.index == 0) {\n                if (otherEnd.index == 0) {\n                    otherEndInd = (!!otherEndInd || otherFrag.ends.length == 1) ? 0 : 1;\n                    otherFrag.reverse();\n                    otherEnd = otherFrag.ends[otherEndInd];\n                }\n            } else {\n                if (otherEnd.index != 0) {\n                    otherEndInd = (!!otherEndInd || otherFrag.ends.length == 1) ? 0 : 1;\n                    otherFrag.reverse();\n                    otherEnd = otherFrag.ends[otherEndInd];\n                }\n            }\n\n            //console.log('after orienting', thisEndInd, otherEndInd);\n\n            var firstFrag = (thisEnd.index == 0) ? otherFrag : this,\n                firstEnd = (thisEnd.index == 0) ? otherEnd : thisEnd,\n                secondFrag = (firstFrag === this) ? otherFrag : this,\n                secondEnd = (firstEnd === thisEnd) ? otherEnd : thisEnd;\n\n            //console.log('first frag', firstFrag, 'first end', firstEnd, 'second frag', secondFrag, 'second end', secondEnd);\n\n            //join\n            //todo - options for html and cut marks etc.\n\n            var joined = firstFrag.sequence.substring(0, firstEnd.index) +\n                Digest.removeMarks(firstEnd.match) +\n                secondFrag.sequence.substring(secondEnd.index + secondEnd.match.length);\n\n            //console.log(joined);\n\n\n            //note - can't leave in cut marks and process -- just use directive tags\n            this.process(joined);\n            return true\n        },\n        alignFragment : function (otherFrag) {\n\n        }\n    };\n\n\n    /**************\n     Primer Design\n     **************/\n\n    /**\n     * @description Get clamp primer using beginning of sequence\n     * @param sequence\n     * @param minTemp Temperature (°C) primer should be. Default 50°C\n     * @returns {string} primer reverse complimentary to sequence, minimum 10nt, maximum 50nt\n     */\n    var generatePrimer = function generatePrimer(sequence, minTemp) {\n        minTemp = !!minTemp ? minTemp : 50;\n\n        var minLength = 10,\n            maxLength = 50,\n            startTest = Math.floor(minTemp / 3.5), //assumes GC_content < 75%\n            index = (startTest > minLength ? startTest : minLength),\n            primer = sequence.substring(0, index);\n\n        while( DNA.melting_temp_basic(primer) < minTemp || index > maxLength){\n            index = index +1;\n            primer = sequence.substring(0, index);\n        }\n\n        return DNA.revcomp(primer);\n    };\n\n    /**************\n     Annealing\n     **************/\n\n    /**\n     * @description Finds indices where primer anneals to sequence, as given by Digest.findIndices() -- i.e. exact match without tail\n     * @param sequence\n     * @param primer\n     * @returns {Object} In form {forward: Array, reverse: Array}} where each array is indices the primer anneals, empty if no matches.\n     */\n    var findAnnealAllExact = function findAnnealAllExact(sequence, primer) {\n\n        //future - move to fuzzy search, account for tail on primer\n\n        var forward = Digest.findIndices(sequence, primer, false);\n        var reverse = Digest.findIndices(sequence, DNA.revcomp(primer), false);\n\n        return {forward: forward, reverse: reverse}\n    };\n\n\n    var findAnnealFuzzy = function(sequence, primer) {\n        //todo\n    };\n\n    //todo - return array of objects, each with index and if forward and has overhang\n    var findAnnealSimple = function(template, primer) {\n        //start from 3', go back until have unique match\n        var searchFrag, searchReg, result = null;\n\n        for(var initialBack = 8,\n                start = primer.length - initialBack,\n                matches = {};\n            start > 0,\n                searchFrag = primer.substring(start),\n                searchReg = Digest.createRegex(searchFrag);\n            --start)\n        {\n            console.log(start);\n\n            //check forward\n            matches.forward = template.match(searchReg) || [];\n            //check revcomp\n            matches.reverse = DNA.revcomp(template).match(searchReg) || [];\n\n            console.log(matches, matches.forward.length, matches.reverse.length, matches.forward.length + matches.reverse.length);\n\n            if (!matches.forward.length && !matches.reverse.length) {\n                console.log('no *exact* matches found for length ' + start + ' from 3 prime end');\n                //todo - step back one, check for single match\n                result = false;\n                break;\n            } else if ((matches.forward.length + matches.reverse.length) == 1) {\n                console.log('one match' );\n                //todo - go back as far as possible\n                //return index of single match\n                result = matches.forward.length ? template.search(searchReg) : DNA.revcomp(template).search(searchReg);\n                break;\n            } else {\n                console.log('else');\n            }\n        }\n\n        return result;\n    };\n\n    //wrapper function...\n    var anneal = function (template, primer, fuzzy) {\n        fuzzy = !!fuzzy || true;\n\n        //future - once write fuzzy, implement here\n        return (fuzzy) ? findAnnealSimple(template, primer) : findAnnealSimple(template, primer);\n\n    };\n\n    //e.g. PCA, given array of oligos, find which match which\n    var annealArray = function (oligos) {\n\n        var track = {};\n        for (var i = 0; i < oligos.length; i++) {\n            track[i] = {oligo : oligos[i]};\n\n            //todo - find matches in oligos\n        }\n\n    };\n\n\n    //TODO - write algorithm that runs the PCR, not as predictive\n\n    /**************\n     PCR algorithms\n     ****************/\n\n\n    /** verification **/\n    /*\n     multiple matches:\n     - will work, multiple (unexpected?) products\n     one match each: {p1_fwd,  p1_rev, p1_absent} x {p2_fwd,  p2_rev, p2_absent}\n     - 3 cases (fails): 1 or both absent\n     - 2 cases (fails): same direction\n     - 2 cases: point toward each other\n     p1 = fwd, p2 = rev (fwd < rev)  or p1 = rev, p2 = fwd (fwd < rev)\n     - 2 cases: point away from each other\n     same as above but (fwd > rev)\n     special cases: ?\n     */\n    /**\n     * @description Determines if primers will anneal and only once (Simple PCR)\n     * @param sequence\n     * @param primer1\n     * @param primer2\n     * @returns {string|boolean} true if no error, otherwise string with error\n     */\n    var verifyPrimers = function verifyPrimers(sequence, primer1, primer2) {\n\n        if (_.isEmpty(primer1) || _.isEmpty(primer2)) {\n            return \"a primer is not defined\"\n        }\n\n        var p1 = findAnnealAllExact(sequence, primer1),\n            p2 = findAnnealAllExact(sequence, primer2);\n\n        /** check zero matches **/\n\n        if (p1.forward.length + p1.reverse.length < 1) {\n            return \"primer1 : no matches\"\n        }\n        if (p2.forward.length + p2.reverse.length < 1) {\n            return \"primer2 : no matches\"\n        }\n\n        /** check multiple matches **/\n\n        if (p1.forward.length + p1.reverse.length > 1) {\n            return \"primer1 : multiple matches\"\n        }\n        if (p2.forward.length + p2.reverse.length > 1) {\n            return \"primer2 : multiple matches\"\n        }\n\n        /** check directions */\n\n        if ((p1.forward.length && p2.forward.length) || (p1.reverse.length && p2.reverse.length))\n            return \"primers point same direction\";\n\n        return true;\n\n    };\n\n\n\n    // see https://www.ncbi.nlm.nih.gov/tools/epcr/\n\n    //wrapper function, currently only handles PCR and EIPCR\n    var predict = function predict(sequence, primers) {\n\n        //console.log(sequence, primers);\n\n        if (primers.length != 2)\n            return \"Can only handle having two primers right now\";\n\n        var primer1 = primers[0],\n            primer2 = primers[1];\n\n        var verify = verifyPrimers(sequence, primer1, primer2);\n        if (verify !== true)\n            return verify;\n\n\n        //future - not DRY\n        var p1 = findAnnealAllExact(sequence, primer1),\n            p2 = findAnnealAllExact(sequence, primer2);\n\n\n        /** orient primers **/\n        //todo - break out\n\n        var p1pos = (!!p1.forward.length) ? +p1.forward[0] : +p1.reverse[0];\n        var p2pos = (!!p2.forward.length) ? +p2.forward[0] : +p2.reverse[0];\n\n\n\n        //pass to protocol\n\n        //p1 forward, p2 reverse\n        if (!!p1.forward.length) {\n            //normal\n            if (p1pos < p2pos) {\n                return PCR(sequence, p1pos, (p2pos + primer2.length));\n            }\n            //eipcr\n            else {\n                return EIPCR(sequence, p1pos, (p2pos+ primer2.length));\n            }\n        }\n        //p2 forward, p1 reverse\n        else {\n            //normal\n            if (p1pos > p2pos) {\n                return PCR(sequence, p2pos, (p1pos + primer1.length));\n            }\n            //eipcr\n            else {\n                return EIPCR(sequence, p2pos, (p1pos + primer1.length));\n            }\n\n        }\n    };\n\n\n\n    /** extension **/\n    //note- currently logic for this functions exists in wrapper function\n\n    var PCR = function PCR(sequence, forwardPrimerPos, reversePrimerPos) {\n        //console.log(arguments);\n        return sequence.substring(forwardPrimerPos, reversePrimerPos);\n    };\n\n    //aka Overlap Extension\n    //note - currently, very simple, only two overlapping primers with defined overlap length\n    var SOEing = function () {\n\n    };\n\n    var EIPCR = function EIPCR(sequence, forwardPrimerPos, reversePrimerPos) {\n        //console.log(arguments);\n        return sequence.substring(forwardPrimerPos) + sequence.substring(0, reversePrimerPos);\n    };\n\n    //30-150 bp, 2 primers w/ homology region (~20bp) and extend\n    var wobble = function wobble(primer1, primer2, overlapLength) {\n        //future - calculate overlapLength if not given\n\n        return primer1 + (DNA.revcomp(primer2)).substring(overlapLength);\n    };\n\n    var PCA = function PCA() {\n\n    };\n\n    var RTPCR = function RTPCR() {\n\n    };\n\n    var Gibson = function Gibson() {\n        //adds ligase (remove nicks)\n        //5' exo nuclease\n    };\n\n    var SLIC = function SLIC() {\n        //3' exo nuclease\n\n    };\n\n\n\n\n\n    /**************\n     Alignment\n     **************/\n    //todo - fold into PCR function\n    //todo - handle multiple lines\n    var primerAlign = function(sequence, primers) {\n        if (primers.length != 2)\n            return \"Can only handle having two primers right now\";\n\n        var primer1 = primers[0],\n            primer2 = primers[1];\n\n        var verify = verifyPrimers(sequence, primer1, primer2);\n        if (verify !== true)\n            return verify;\n\n\n        //future - not DRY\n        var p1 = findAnnealAllExact(sequence, primer1),\n            p2 = findAnnealAllExact(sequence, primer2);\n\n\n        /** orient primers **/\n        //todo - break out\n\n        var p1pos = (!!p1.forward.length) ? +p1.forward[0] : +p1.reverse[0];\n        var p2pos = (!!p2.forward.length) ? +p2.forward[0] : +p2.reverse[0];\n\n        //console.log(p1pos, p2pos, sequence, primers[0], primers[1]);\n\n        //todo - don't assume p1 first\n\n        var line1 = DNA.createRun(' ', p1pos);\n        line1 += (!!p1.forward.length) ? primers[0] : DNA.revcomp(primers[0]);\n        line1 += DNA.createRun(' ', (p2pos - p1pos - primers[0].length));\n        line1 += (!!p2.forward.length) ? primers[1] : DNA.revcomp(primers[1]);\n        line1 += DNA.createRun(' ', (sequence.length - line1.length));\n\n        //note - handle line breaks outside function\n        return (line1);\n    };\n\n\n\n\n    /**************\n     ligation\n     **************/\n\n\n\n    /**\n     * @description Ligates two fragments. Optionally, shows alignment of ligation\n     * @param fragments {Array} NOTE Currently only two\n     * @param align {boolean} Whether to show alignment (both strands)\n     * @param showHTML {boolean} Include HTML tags marking original fragments and complementarity region. Recommended when displaying as HTML. Default false.\n     * @param showMarks {boolean} maintain cut marks. Not relevant if showHTML. Default false.\n     * @returns {string}\n     */\n    var ligateOld = function(fragments, align, showHTML, showMarks) {\n\n        var fragments = parseFragments(fragments),\n            blunts,\n            overhangs,\n            fragPair;\n\n        if (blunts.length > 1) {\n            if (blunts.length == 2) {\n                console.log('2 blunt ends -- expect random products, just showing one');\n                fragPair = orientFragmentsForJoin(blunts[0], blunts[1]);\n            }\n            else {\n                //several weird products\n                return 'multiple blunt end fragments -- random products'\n            }\n        }\n\n        if (overhangs.length > 1) {\n            if (overhangs.length == 2) {\n                fragPair = orientFragmentsForJoin(overhangs[0], overhangs[1]);\n                return joinTwoFragments(fragPair, align, showHTML, showMarks);\n            } else {\n                //multiple pairs\n                console.log('more than 2 overhangs', overhangs);\n            }\n        }\n\n\n\n                /* rearchitecture:\n\n                 todo - non-terminal ends should be cut before go through\n\n                 todo ---- each fragment should maintain both of its ends, organize pointers by fragment -> end -> pointer ----- don't separate into separate fragments\n\n\n                 note - aaaaA^AGGT_Tgggg = ccccT^TCCA_Atttt\n\n\n                 */\n\n\n\n                function findConnections(overhangs) {\n                    var pointers = {};\n\n                    _.each(overhangs, function(currentHang, indout) {\n                        _.each(overhangs, function(otherHang, indin) {\n                            if (indout != indin) {\n                                var curEnd = currentHang.end.match,\n                                    otherEnd = otherHang.end.match;\n\n                                //if ends are complimentary\n                                if (curEnd == otherEnd || curEnd == DNA.revcomp(otherEnd)) {\n                                    //first, check don't have the other way mapped\n                                    if (!pointers[indin] || pointers[indin] != indout) {\n                                        if (!pointers[indout]) {\n                                            pointers[indout] = indin;\n                                        } else {\n                                            //points to two fragments\n                                            return 'fragment ' + indout + ' has multiple complementary fragments: ' + indin + ' and ' + pointers[indout];\n                                        }\n                                    }\n                                }\n                            }\n                        })\n                    });\n\n                    //can assume at this point all pointers are unique and one way\n                    console.log(pointers);\n\n                    if (!_.keys(pointers).length) return false;\n\n                    return pointers;\n                }\n\n                function makeConnections(pointers) {\n                    var products = [];\n                    //todo - handle 3+ way binds (i.e. check next for partner)\n                    _.each(pointers, function (value, key) {\n                        fragPair = orientFragmentsForJoin(overhangs[key], overhangs[value]);\n                        products.push(joinTwoFragments(fragPair, align, showHTML, showMarks))\n                    });\n\n\n                    console.log(products);\n\n                    return products;\n                }\n\n                //fixme -- need to process ends again\n                var inputFrags = overhangs,\n                    pointers,\n                    products;\n                while (!!(pointers = findConnections(inputFrags)) ) {\n                    products = makeConnections(pointers);\n                    inputFrags = products;\n                }\n\n\n\n                return products;\n\n\n\n\n\n                 /*var matches = {};\n\n                 _.each(overhangs, function(overhang, outerIndex) {\n                 var curHang = overhangs[outerIndex].end.match;\n                 _.each(overhangs, function(overhang, InnerIndex) {\n                 console.log('overhang ' + outerIndex + ' match ' + InnerIndex, curHang == overhang.end.match, curHang == DNA.revcomp(overhang.end.match), overhangs[outerIndex] !== overhang);\n                 if ((curHang == overhang.end.match || curHang == DNA.revcomp(overhang.end.match)) && overhangs[outerIndex] !== overhang) {\n                 matches[outerIndex] = !!matches[outerIndex] ? matches[outerIndex].push(InnerIndex) : [InnerIndex];\n                 }\n                 });\n                 });\n\n                 //console.log(matches);\n\n                 //check for arrays.length > 1\n                 if (_.filter(matches, function(matchArr, key) { return matchArr.length != 1; }).length)\n                 return 'more than one match for some overhangs';\n\n                 if (!matches.length) {\n                 //if only two, just do the fragPair thing\n                 if (_.keys(matches).length == 2) {\n                 console.log('only one set of matching overhangs');\n\n                 if (overhangs.length > _.keys(matches).length)\n                 console.log('some fragments ends did not match and will be ignored');\n\n                 //just pull one\n                 var key = _.keys(matches)[0],\n                 match = matches[key][0];\n                 fragPair = orientFragmentsForJoin(overhangs[key], overhangs[match]);\n                 }\n                 else {\n                 return 'multiple (' + _.keys(matches).length + ') sets of matches -- currently can only handle 2 matching overhangs';\n\n                 }\n                 } else {\n                 return 'no matching overhangs'\n                 }\n            }\n        }\n        */\n    };\n\n\n\n    //DEPRECATED\n    //todo - incorporate into Fragment.joinFragment\n    var joinTwoFragments = function (fragPair, align, showHTML, showMarks) {\n\n        if (!fragPair)\n            return 'cut marks not defined';\n\n        //todo - why is this here?\n        if (fragPair[0].end.match != DNA.revcomp(fragPair[1].end.match))\n            return 'overhangs not complimentary (5\\' orientation): ' + fragPair[0].end.match + ' : ' + fragPair[1].end.match;\n\n\n        var matchType = (fragPair[0].end.isBlunt) ? 'bluntmatch' : 'stickymatch';\n\n        var finalText = '<ligate-frag>' + (fragPair[0].fragment).substring(0, fragPair[0].end.index) + '</ligate-frag>' +\n            '<ligate-'+matchType+'>' +\n            (showMarks ? fragPair[0].end.match : Digest.removeMarks(fragPair[0].end.match ))+\n            '</ligate-'+matchType+'>' +\n            (fragPair[1].fragment).substring(fragPair[1].end.index + fragPair[1].end.match.length);\n\n\n        if (!!align) {\n            var line2 = DNA.complement((fragPair[0].fragment).substring(0, fragPair[0].end.index)) +\n                '<ligate-'+matchType+'>' +\n                (showMarks ? fragPair[1].end.match : Digest.removeMarks(fragPair[1].end.match ))+\n                '</ligate-'+matchType+'>' +\n                '<ligate-frag>' + DNA.complement((fragPair[1].fragment).substring(fragPair[1].end.index + fragPair[1].end.match.length)) + '</ligate-frag>';\n\n            finalText += \"\\n\" + line2;\n        }\n\n        if (!showHTML) {\n            finalText = finalText.replace(/(<([^>]+)>)/ig, '');\n        }\n\n        //fixme - handle differently -- shouldn't remove marks outside of ligation\n        /*if (!showMarks && !showHTML) {\n         finalText = Digest.removeMarks(finalText);\n         }*/\n\n        return finalText\n    };\n\n\n    //given strings, creates fragments with terminal ends\n    //shouldTrim --- for internal cuts,\n    //  true = sequence past overhang removed,\n    //  false = split into fragments\n    var parseFragments = function PCR_parseFragments (fragments, shouldTrim) {\n\n        var parsedFrags = [];\n        _.each(fragments, function(frag, indout) {\n\n            //e.g. if pass in digest array directly, assume sorted and take first\n            if (_.isArray(frag))\n                frag = frag[0];\n\n            //nonterminal marks\n            if ((Digest.findOverhangs(frag, true)).length) {\n                if (shouldTrim) {\n                    var trimmed = Digest.trimPastInternal(frag, true);\n                    parsedFrags.push(new Fragment(trimmed))\n\n                } else {\n                    _.each(Digest.makeCuts(frag), function (cutFrag) {\n                        parsedFrags.push(new Fragment(cutFrag));\n                    });\n                }\n            }\n            else {\n                parsedFrags.push(new Fragment(frag));\n            }\n        });\n\n        return parsedFrags;\n    };\n\n\n    /**\n     *\n     * @param {Array} fragments Array of Strings WITH cut marks\n     */\n    //todo - add options -- HTML & alignment\n    var ligate = function(fragments) {\n        fragments = parseFragments(fragments, true);\n        //console.log('ligate starting -- fragments:', fragments);\n\n\n\n        //use for loop so can decrement counter\n        for (var outerInd = 0; outerInd < fragments.length; outerInd++) {\n            if (fragments.length == 1) break;\n\n            var outerFrag = fragments[outerInd];\n\n            var toJoinIndex = outerFrag.findFirstMatchIndex(fragments);\n\n            if (toJoinIndex >= 0) {\n                //testing\n                //console.log('outer frag at index ' + outerInd, outerFrag);\n                //console.log('first match at index ' + toJoinIndex, fragments[toJoinIndex]);\n\n                outerFrag.joinFragment(fragments[toJoinIndex]);\n\n                //console.log('outer frag is now:', outerFrag, \"\\n\\n\\n\\n\\n\");\n                fragments.splice(toJoinIndex, 1);\n                outerInd--;\n            }\n        }\n\n        _.each(fragments, function(fragment) {\n            fragment.circularize();\n        });\n\n        //console.log('LIGATE FINAL:', fragments);\n\n        if (fragments.length == 1)\n            return fragments[0].sequence;\n        else\n            return _.pluck(fragments, 'sequence');\n    };\n\n    return {\n        //PCR\n        predict : predict,\n\n        //Annealing\n        anneal : anneal,\n        findAnnealSimple : findAnnealSimple,\n\n        //Alignment\n        primerAlign : primerAlign,\n\n        //Ligate\n        parseFragments : parseFragments,\n        ligate : ligate\n\n\n    };\n\n}());"}
]