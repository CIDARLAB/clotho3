[
    {
        "schema":"Function",
        "id":"523e3b4cc2e6967acacb1722",
        "dependencies":["523e36e1c2e647abe23c1fa5"],
        "args":[{"type":"string","name":"sequence"}],
        "name":"DigestModuleTest",
        "code":"function(seq) { return Digest.digest(seq, Digest.enzymes.EcoRI); };","language":"JAVASCRIPT",
        "tests":[{"args":["ccagtcggaattctacat"],"output":{"value":"ccagtcgg^aatt_ctacat","type":""}}]
    },
    {"schema": "Module", "name": "Digest", "language": "JAVASCRIPT", "dependencies":["523e36e1c2e647abe23c1fa4"], "id": "523e36e1c2e647abe23c1fa5", "code" : "(function digest_module() {\nvar enzymes = {\n        \"BglII\" : {\n            \"name\" : \"BglII\",\n            \"match\" : \"agatct\",\n            \"cut\" : \"a^gatc_t\",\n            \"strand\" : \"\",\n            \"methylation\" : false,\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"S\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : false,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/BglII.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"BsaI\" : {\n            \"name\" : \"BsaI\",\n            \"match\" : \"ggtctc\",\n            \"cut\" : \"ggtctc (1/5)\",\n            \"strand\" : \"\",\n            \"methylation\" : false,\n            \"overhang\" : 3,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : false,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/BsaI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"BsmbI\" : {\n            \"name\" : \"BsmbI\",\n            \"match\" : \"cgtctc\",\n            \"cut\" : \"cgtctc (1/5)\",\n            \"strand\" : \"\",\n            \"methylation\" : true,\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"S\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : false,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/BsmbI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"XhoI\" : {\n            \"name\" : \"XhoI\",\n            \"match\" : \"ctcgag\",\n            \"cut\" : \"c^tcga_g\",\n            \"strand\" : \"\",\n            \"methylation\" : true,\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : false,\n            \"comment\" : \"flanking C5 methylation can slow cleavage, ATCTCTCGAGTCTA is cut v. slowly\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/XhoI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"BamHI\" : {\n            \"name\" : \"BamHI\",\n            \"match\" : \"ggatcc\",\n            \"cut\" : \"g^gatc_c\",\n            \"strand\" : \"\",\n            \"methylation\" : {},\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : false,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/BamHI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"EcoRI\" : {\n            \"name\" : \"EcoRI\",\n            \"match\" : \"gaattc\",\n            \"cut\" : \"g^aatt_c\",\n            \"strand\" : \"\",\n            \"methylation\" : {},\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : true,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/EcoRI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"XbaI\" : {\n            \"name\" : \"XbaI\",\n            \"match\" : \"tctaga\",\n            \"cut\" : \"t^ctag_a\",\n            \"strand\" : \"\",\n            \"methylation\" : {},\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : true,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/XbaI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"SpeI\" : {\n            \"name\" : \"XbaI\",\n            \"match\" : \"actagt\",\n            \"cut\" : \"a^ctag_t\",\n            \"strand\" : \"\",\n            \"methylation\" : true,\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : true,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/SpeI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"PstI\" : {\n            \"name\" : \"PstI\",\n            \"match\" : \"ctgcag\",\n            \"cut\" : \"c_tgca^g\",\n            \"strand\" : \"\",\n            \"methylation\" : {},\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : true,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/PstI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"HindIII\" : {\n            \"name\" : \"HindIII\",\n            \"match\" : \"aagctt\",\n            \"cut\" : \"a^agct_t\",\n            \"strand\" : \"\",\n            \"methylation\" : {},\n            \"overhang\" : 4,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : true,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/HindIII.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"AlwnI\" : {\n            \"name\" : \"AlwnI\",\n            \"match\" : \"cagnnnctg\",\n            \"cut\" : \"cag_nnn^ctg\",\n            \"strand\" : \"\",\n            \"methylation\" : {},\n            \"overhang\" : 3,\n            \"type\" : \"II\",\n            \"subtype\" : \"P\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : false,\n            \"comment\" : \"\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/AlwnI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"AcuI\" : {\n            \"name\" : \"AcuI\",\n            \"match\" : \"ctgaag\",\n            \"cut\" : \"ctgaag (16/14)\",\n            \"strand\" : \"\",\n            \"methylation\" : {},\n            \"overhang\" : 2,\n            \"type\" : \"II\",\n            \"subtype\" : \"G, S, alpha\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : false,\n            \"comment\" : \"Methylated product: 6-methyladenosine (base undetermined)\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/XbaI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        },\n        \"BseRI\" : {\n            \"name\" : \"BseRI\",\n            \"match\" : \"gaggag\",\n            \"cut\" : \"gaggag (10/8)\",\n            \"strand\" : \"\",\n            \"methylation\" : {},\n            \"overhang\" : 2,\n            \"type\" : \"II\",\n            \"subtype\" : \"G, S\",\n            \"notes\" : {},\n            \"buffer\" : \"\",\n            \"star activity\" : false,\n            \"comment\" : \"Methylated Product: 6-methyladenosine (base undetermined)\",\n            \"rebase\" : \"http://rebase.neb.com/rebase/enz/XbaI.html\",\n            \"personal\" : {},\n            \"citations\" : {},\n            \"ordering\" : {}\n        }\n    };\n\n    //calculated on the fly, reverse lookup by match or cut sequence\n    var enzymesReverse = {};\n    _.forEach(enzymes, function (enz, name) {\n        enzymesReverse[enz.match] = name;\n        enzymesReverse[enz.cut] = name;\n    });\n\n    var cutMarks = {\n        'blunt' : {\n            mark: '|',\n            type: 'Blunt',\n            description: 'A cut that results in no \"sticky\" ends, or overhangs. '\n        },\n        'main' : {\n            mark: '^',\n            type: 'Main Strand',\n            description: 'Denotes a cut on the 5\\' -> 3\\' (primary) strand, usually visualized as the \"top\" strand.'\n        },\n        'comp' : {\n            mark: '_',\n            type: 'Complementary Strand',\n            description: 'Denotes a cut on the 3\\' -> 5\\' (complementary) strand, usually visualized as the \"bottom\" strand.'\n        }\n    };\n\n    var regexps = {};\n    regexps.localCuts = /\\(((.*?)([\\^|_])(.+?)([\\^|_])(.*?))|((.*?)(\\|)(.*?))\\)/ig;\n    regexps.nonLocalCuts = /\\((\\d+)\\/(\\d+)\\)/ig;\n    regexps.findCut = /(\\|)|([\\^_])(.+?)([_\\^])/ig;\n    regexps.findBlunt = /(\\|)/ig;\n    regexps.findOverhang = /([\\^_])(.+?)([_\\^])/ig;\n\n    /**\n     * @description Extend a sequence by a defined length, repeating monomers from the beginning.\n     * @param {String} sequence\n     * @param {Number} lookahead Length to extend. Example lookahead length is (enzyme.match.length - 1)\n     * @returns {string} Extended sequence\n     */\n    var extendSequence = function (sequence, lookahead) {\n        return (sequence + sequence.substr(0, lookahead));\n    };\n\n    /**\n     * @description Given an UNSORTED (i.e. order in which linear sequence was cut) array of fragments, will join the first fragment to the last fragment, approximating the result of cutting a circular instead of linear sequence.\n     * @param {Array} fragments Array of sequence fragments, MUST BE ORDERED SUCH THAT fragments[0] is the first one, and fragments[length-1] is the last one, if the sequence were linear.\n     * @returns {Array}\n     */\n    var circularize = function (fragments) {\n        if (fragments.length > 1) {\n            var first = fragments.shift();\n            fragments[fragments.length-1] = fragments[fragments.length-1] + first;\n        }\n        return fragments;\n    };\n\n\n    /**\n     * @description Creates a regular expression for a given enzyme, converting degenerate match sequence appropriately\n     * @example ACGTBDHVN -> ACGT[CGTU][AGTU][ACTU][ACG][ACGTU]\n     * @param {String} match String to use as Regexp, e.g. enzyme.match\n     * @param {boolean=} doubleStrand  Whether match should account for both strands (revcomp). Default is false.\n     * @returns {RegExp}\n     */\n    var createRegex = function (match, doubleStrand) {\n        var degen = doubleStrand ? (match + '|' + DNA.revcomp(match)) : match;\n        return new RegExp(DNA.undegenerize(degen), 'ig');\n    };\n\n\n    /**\n     * @description Determine if an enzyme matches a given sequence\n     * @param {String} sequence Sequence to check\n     * @param {String} match String to use as Regexp, e.g. enzyme.match\n     * @returns {boolean} Returns true if match, false otherwise\n     */\n    var sitePresent = function (sequence, match) {\n        return (createRegex(match, true)).test(extendSequence(sequence, match.length-1));\n    };\n\n\n    /**\n     * @description Identify the enzyme whose recognition sequence matches 'match'\n     * @param match Should match either enzyme.match or enzyme.cut\n     * @returns {string} Name of enzyme, same as key in enzymes object\n     */\n    var identifySite = function (match) {\n        return enzymesReverse[match];\n    };\n\n    /**\n     * @description Adds a restriction site to the end of the sequence (3') with a given gap\n     * @param {String} sequence\n     * @param {Object} enzyme\n     * @param {Number} gap Number of nucleotides as spacer. Default is 3.\n     * @param {boolean} fivePrime Whether site should be added to 5' (beginning) or 3' (end)\n     * @param {boolean} oppStrand Whether site is on opposite strand (should be reverse complemented)\n     */\n    var addRestrictionSite = function (sequence, enzyme, gap, fivePrime, oppStrand) {\n        gap = _.isUndefined(gap) ? 3 : gap;\n\n        var adding = DNA.randomSequence(gap) +\n            (oppStrand ? DNA.revcomp(enzyme.match) : enzyme.match) +\n            DNA.randomSequence(gap);\n        return (!!fivePrime) ? adding + sequence : sequence + adding;\n    };\n\n    /**\n     * @description attempts to alter sequence preserving protein sequence, but removing sequence specified (e.g. enzyme.match)\n     * @param sequence\n     * @param {RegExp|String} match Either a Regular Expression, or string to use as Regexp (e.g. enzyme.match)\n     * @param forceOffset\n     * @return {boolean|string} Altered sequence, false if could not swap. Changes will be lowercase\n     */\n    var swapoutSites = function (sequence, match, forceOffset) {\n        var offset = forceOffset ? forceOffset : DNA.probableORF(sequence),\n            matches = findMatches(sequence, match, true),\n            indices = Object.keys(matches);\n\n        //we're ok\n        if (matches.length == 0) return sequence;\n\n        var testReg = (match instanceof RegExp) ? match : createRegex(match, true);\n\n        //loop each index with a match\n        loop_eachIndex: for (var i = 0; i < indices.length; i++) {\n            var index = indices[i],\n                curMatch = matches[index],\n                start = index - (index % 3) + offset,\n                numCodons = Math.ceil((curMatch.length + (index - start)) % 3);\n\n            //loop through codons containing match\n            loop_eachCodon : for (var j = 0; j <= numCodons; j++) {\n                var curIndex = start + j*3,\n                    codon = sequence.substr(curIndex, 3).toLowerCase(),\n                    amino = DNA.complements.translate[codon],\n                    options = DNA.complements.reverse_translate[amino],\n                    replacement;\n\n                if (options.length <= 1)\n                    continue;\n\n                // loop through options for codon.\n                // If remove match, break loop_eachCodon. Otherwise, return false;\n                loop_eachOption : for (var k = 0; k < options.length; k++) {\n                    if (options[k] == codon) continue;\n\n\n\n                    //todo - don't test whole sequence, just this selection\n                    var testSeq = sequence.substr(0, curIndex) + options[k] + sequence.substr(curIndex+3);\n                    if (!testReg.test(testSeq)) {\n                        sequence = testSeq;\n                        break loop_eachCodon;\n                    }\n\n                }\n\n\n\n                //todo - finish -- if not good after each codon, return false\n                if (testReg.test()) {}\n\n\n\n\n\n\n                //future - check codon frequencies\n\n\n            }\n\n            // todo\n            //handle degenerate matches\n\n\n            /*\n             offset 1\n             acgtacgtATGCATacgtacgt\n\n             index 8\n\n             -> codons @ 7-8-9 (tAT), 10-11-12 (GCA), 13-14-15 (Tac)\n             start = index - (index % 3) + offset = 7\n             numCodons = Math.ceil((match.length + (index - start)) % 3)\n\n             ->\n\n\n\n             */\n\n\n            if (impossible) return false\n        }\n\n        return sequence\n    };\n\n\n    /**\n     * @description Find matches for a given oligo in a sequence\n     * @param sequence\n     * @param {RegExp|String} match Either a Regular Expression, or string to use as Regexp (e.g. enzyme.match)\n     * @param {boolean} bothStrands Whether revcomp of match should be searched as well. Default is true\n     * @returns {object} Matches in form { <match index> : <matched value> }\n     */\n    var findMatches = function (sequence, match, bothStrands) {\n        var matches = {},\n            cur,\n            reg = (match instanceof RegExp) ? match : createRegex(match, bothStrands !== false);\n\n        //future - move to fuzzy search\n\n        while ((cur = reg.exec(extendSequence(sequence, match.length-1))) != null) {\n            matches[cur.index] = match;\n        }\n\n        return matches;\n    };\n\n\n    /**\n     * @description Finds start indices of a oligo's match in a sequence\n     * @param {String} sequence\n     * @param {RegExp|String} match Either a Regular Expression, or string to use as Regexp (e.g. enzyme.match)\n     * @param {boolean} bothStrands Whether revcomp of match should be searched as well. Default is true\n     * @returns {Array} List of sites (start of match). Empty if no matches\n     */\n    var findIndices = function (sequence, match, bothStrands) {\n        return Object.keys(findMatches(sequence, match, bothStrands));\n    };\n\n\n\n    var removeCuts = function(sequence) {\n        return sequence.replace(/[\\|\\^_]/gi, '')\n    };\n\n    var removeMatches = function(sequence) {\n        return sequence.replace(/[\\(\\)]/gi, '')\n    };\n\n    var removeMarks = function (sequence) {\n        return removeMatches(removeCuts(sequence));\n    };\n\n    /**\n     * @description Marks enzyme recognitions sites and cut marks on a sequence\n     * @param {string} sequence\n     * @param {object} enzyme\n     * @returns {string} Returns sequence with cuts and recognition sites marked\n     *\n     * @example [Normal]\n     * BamHI { \"cut\" : \"g^gatc_c\" }\n     * NNNNNggatccNNNN -> NNNNN(g^gatc_c)NNNNN\n     *\n     * @example [Nonlocal]\n     * BsmbI { \"cut\" : \"cgtctc (1/5)\" }\n     * NNNcgtctcNNNNNNNNN -> NNN(cgtctc)N^NNNN_NNNN\n     *\n     * @example [Nonlocal Revcomp]\n     * BsmbI { \"cut\" : \"cgtctc (1/5)\" }\n     * NNNNNNNNNgagacgNNN -> NNNN_NNNN^N(gagacg)NNN\n     *\n     * @example [3' overhang]\n     * BseRI { \"cut\" : \"gaggag (10/8)\" }\n     * NNNgaggagNNNNNNNNNNNNNNNNNNNN -> NNN(gaggag)NNNNNNNN_NN^NNNNNNNNNN\n     *\n     * @example [3' side]\n     * {\"cut\" : \"atgcat (-5/-1)\" }\n     * NNNNNNNNNNatgcatNNN -> NNNNN^NNNN_N(atgcat)NNN\n     *\n     * @example [3' side, revcomp]\n     * {\"cut\" : \"atgcat (-5/-1)\" }\n     * NNNatgcatNNNNNNNNNN -> NNN(atgcat)N^NNNN_NNNNN\n     */\n\n    //future - handle cuts on both sides (e.g. Bsp24I (8/13)GACNNNNNNTGG(12/7) and one on either side\n\n    //todo - multiple enzymes --- ignore cutMarks in recognition if already digested\n\n    var markSites = function (sequence, enzymes) {\n\n        if (!enzymes) return sequence;\n\n        //sequence = DNA.dnaOnly(sequence);\n\n        //todo - write function to call in loop instead of this hack\n        enzymes = _.isArray(enzymes) ? enzymes : [enzymes];\n\n        _.each(enzymes, function (enzyme) {\n            var nonLocalCuts = (/\\((\\d+)\\/(\\d+)\\)/ig).exec(enzyme.cut);\n\n            if (nonLocalCuts) {\n\n                //matches to extract (for constructing regexp) - backreferences\n                var brs = {};\n                brs.enz = '(' + DNA.undegenerize(enzyme.match) + ')';\n                brs.rev = '(' + DNA.undegenerize(DNA.revcomp(enzyme.match)) + ')';\n\n                var cut53 = ['^', '_'],\n                    cut35 = ['_', '^'];\n\n                // whether first cut is parent or complimentary strand (^..._ vs _...^)\n                // i.e. 3' or 5' overhang\n                var cut = (nonLocalCuts[1] < nonLocalCuts[2]) ? cut53 : cut35;\n\n                //cuts before recognition sequence (e.g. AGTACT (-5/-1)\n                if (nonLocalCuts[1] < 0) {\n\n                    brs.gap1 = '(.{'+Math.abs(nonLocalCuts[1]-nonLocalCuts[2])+'})';\n                    brs.gap2 = '(.{'+Math.abs(nonLocalCuts[2])+'})';\n\n                    //forward\n                    var cutFor = new RegExp(brs.gap2 + brs.gap1 + brs.enz, 'ig');\n                    sequence = sequence.replace(cutFor, function(match, $1, $2, $3, off, orig) {\n                        return [ cut[0] + $1 + cut[1] + $2 + '(' + $3 + ')']\n                    });\n                    //reverse\n                    var cutRev = new RegExp(brs.enz + brs.gap1 + brs.gap2, 'ig');\n                    sequence = sequence.replace(cutRev, function(match, $1, $2, $3, off, orig) {\n                        return [ '(' + $1 + ')' + $2 + cut[0] + $3 + cut[1]]\n                    });\n\n                }\n                else {\n                    brs.gap1 = '(.{'+nonLocalCuts[1]+'})';\n                    brs.gap2 = '(.{'+(nonLocalCuts[2]-nonLocalCuts[1])+'})';\n\n                    //forward\n                    var cutFor = new RegExp(brs.enz + brs.gap1 + brs.gap2, 'ig');\n                    sequence = sequence.replace(cutFor, function(match, $1, $2, $3, off, orig) {\n                        return [ '(' + $1 + ')' + $2 + cut[0] + $3 + cut[1]]\n                    });\n                    //reverse\n                    var cutRev = new RegExp(brs.gap2 + brs.gap1 + brs.rev, 'ig');\n                    sequence = sequence.replace(cutRev, function(match, $1, $2, $3, off, orig) {\n                        return [ cut[0] + $1 + cut[1] + $2 + '(' + $3 + ')']\n                    });\n                }\n\n            } else {\n                //note - already account for cut marks being reverse complimented\n                sequence = sequence.replace(createRegex(enzyme.match), '(' + enzyme.cut + ')');\n                sequence = sequence.replace(createRegex(DNA.revcomp(enzyme.match)), '(' + DNA.revcomp(enzyme.cut) + ')');\n            }\n\n\n            //todo handle lookahead\n            var wrap = sequence.substring(sequence.length - enzyme.match.length) + sequence.substr(enzyme.match.length-1);\n            if (createRegex(enzyme.match).exec(wrap)) {\n\n                // including nonLocal\n\n                if (nonLocalCuts) {\n\n                } else {\n\n                }\n            }\n        });\n\n        return sequence;\n    };\n\n    /**\n     * @description Marks recognition sites by surrounding with parentheses\n     * @param {string} sequence\n     * @param {object} enzyme\n     * @returns {string} Sequence with marked restriction sites\n     */\n    var markMatches = function (sequence, enzyme) {\n        //todo - shouldn't get rid of cuts already there\n        return removeCuts(markSites(sequence, enzyme))\n    };\n\n\n    /**\n     * @description Marks only cut sites without marking matched sequences\n     * @param {string} sequence\n     * @param {object} enzyme\n     * @returns {string}\n     */\n    var markCuts = function (sequence, enzyme) {\n        //todo - shouldn't get rid of matches already there\n        return removeMatches(markSites(sequence, enzyme))\n    };\n\n    /**\n     * @description\n     * @param sequence\n     * @returns {Array} array of objects:\n     * Some keys:\n     *      0-4 : <matches from regex>\n     *      index: index of match\n     *      input: passed in sequence\n     *      isBlunt: if blunt cut (i.e. \"|\")\n     *      length: length of match\n     *      match: matched overhang sequence, including marks\n     *      overhang : overhang without cut marks, nothing if blunt\n     *      is3prime : true for 3' overhang (e.g. nnn_nnnn^nnn)\n     *      terminal : true if cut mark is on either end of fragment passed in\n     *\n     *\n     * @example \"acgt^ct_acagctagcta|gctagctagct_cgta^agagctacga\"\n     0: Array[5]\n     0: \"^ct_\"\n     1: undefined\n     2: \"^\"\n     3: \"ct\"\n     4: \"_\"\n     index: 4\n     input: \"acgt^ct_acagctagcta|gctagctagct_cgta^agagctacga\"\n     isBlunt: false\n     length: 4\n     match: \"^ct_\"\n     is3prime: false\n     terminal : false\n     1: Array[5]\n     0: \"|\"\n     1: \"|\"\n     2: undefined\n     3: undefined\n     4: undefined\n     index: 19\n     input: \"acgt^ct_acagctagcta|gctagctagct_cgta^agagctacga\"\n     isBlunt: true\n     length: 1\n     match: \"|\"\n     is3prime: null\n     terminal : false\n     2: Array[5]\n     0: \"_cgta^\"\n     1: undefined\n     2: \"_\"\n     3: \"cgta\"\n     4: \"^\"\n     index: 31\n     input: \"acgt^ct_acagctagcta|gctagctagct_cgta^agagctacga\"\n     isBlunt: false\n     length: 6\n     match: \"_cgta^\"\n     is3prime: true\n     terminal : false\n     */\n    var findOverhangs = function (sequence, nonterminalOnly) {\n        var regCut = regexps.findCut,\n            match,\n            matches = [];\n\n        while ((match = (regCut).exec(sequence)) != null) {\n            match.match = match[0];\n            match.isBlunt = (match.match == '|');\n            match.is3prime = match.isBlunt ? null : (match[2] == '_');\n            match.overhang = match.isBlunt ? '' : match[3];\n            match.length = match.match.length;\n            match.terminal = !!(( match.index == 0 ||\n                (match.index + (match.isBlunt ? 1 : match.length) == sequence.length )\n                ));\n\n            if (nonterminalOnly) {\n                !match.terminal && matches.push(match);\n            } else {\n                matches.push(match);\n            }\n        }\n\n        return matches;\n    };\n\n    /**\n     * @description Determine fragments for a sequence cut by a single enzyme\n     * @param {string} sequence WITH cut marks already\n     * @param {boolean=} circular Whether fragments should be circularized. Default: false\n     * @returns {Array} Array of strings representing cut fragments\n     */\n\n    /*\n     Given ( X -> Y, V -> W as complements, with ' denoting reverse order)\n\n     XacatgtV    __\\ Xa^catg_ = ^catg_tY' and ^catg_tV = W'a^catg_\n     YtgtacaW      /\n\n\n     nnnn^nn_nnnn -> [nnnn^nn_, ^nn_nnnn]\n     nnn|nnn -> [nnn, nnn]\n     */\n    var makeCuts = function (sequence, circular) {\n\n        var lastIndex = 0,\n            lastMark = \"\",\n            keys = [],\n            fragments = [],\n            overhangs = findOverhangs(sequence);\n\n        //ensure sorted\n        for (var ind in overhangs) {\n            if (overhangs.hasOwnProperty(ind)) {\n                keys.push(ind)\n            }\n        }\n        keys.sort();\n\n        //split into fragments\n        for (var i = 0; i < keys.length; i++) {\n            var mark = overhangs[keys[i]],\n                newMark = (mark.isBlunt) ? '' : mark.match,\n                frag = sequence.substring(lastIndex, mark.index) + newMark;\n\n            fragments.push(frag);\n\n            lastIndex = mark.index;\n            lastMark = newMark;\n        }\n\n        //last fragment\n        fragments.push(sequence.substring(lastIndex));\n\n        return (!!circular) ? circularize(fragments) : fragments;\n    };\n\n\n    var sortFragments = function(fragments) {\n        return _.sortBy(fragments, function(f) { return -f.length });\n    };\n\n    //if leave out targetLength, get longest\n    var gelPurify = function(fragments, targetLength) {\n        if (_.isString(fragments)) return fragments;\n\n        //todo - clean up logic\n        var index;\n        if (_.isUndefined(targetLength)) {\n            targetLength = 0;\n            index = fragments.length - 1;\n        } else {\n            index = 0;\n        }\n        return _.sortBy(fragments, function (f) { return Math.abs(f.length - targetLength)})[index]\n    };\n\n\n    /*************\n     End Pruning\n     *************/\n\n    /**\n     * @description Removes any sequence contained within an overhang\n     * @param sequence\n     * @returns {string}\n     */\n    var removeOverhangs = function (sequence) {\n        return sequence.replace(/(_.+?\\^)|(\\^.+?_)|(\\|)/ig, '');\n    };\n\n    //note - currently only handles one internal cut\n    var trimPastInternal = function (sequence, keepLongest) {\n        var firstInternal = _.find(findOverhangs(sequence), function (overhang) {\n            console.log(overhang);\n            return !overhang.terminal;\n        });\n\n        //if keepLongest and second fragment longer than first\n        if (keepLongest && (firstInternal.index < sequence.length - firstInternal.index - firstInternal.length)) {\n            return sequence.substring(firstInternal.index)\n        } else {\n            return sequence.substring(0, firstInternal.index + firstInternal.length);\n        }\n\n    };\n\n    /**\n     * @description\n     * @param sequence\n     *\n     * @example nnnnnn -> nnnnnn\n     * @example nn_nnnn^ -> nn\n     * @example nnnn_nnnnnnn -> nnnn\n     * todo - handle beyond only sticky ends\n     */\n    var exonuclease35 = function(sequence) {\n\n        if (sequence.indexOf('_') < 0)\n            return sequence;\n\n        var regex = /(.*?)(_.+?\\^?.*)/gi,\n            matches = regex.exec(sequence),\n            removed = matches[2],\n            remaining = matches[1];\n\n        return remaining;\n    };\n\n    /**\n     * @description\n     * @param sequence\n     *\n     * @example\n     * note - also handle beyond only sticky ends\n     */\n    var exonuclease53 = function(sequence) {\n        //todo\n\n    };\n\n    /**\n     * @description\n     * @param sequence\n     *\n     * @example nnnnnn -> nnnnnn\n     * @example nn^nnnn -> ___________\n     * @example nn^nnnn_ -> nnnnnn\n     * @example nn_nnnn^nn -> ______________ exonuclease activity?\n     *\n     * todo - determine above, also handle beyond only sticky ends\n     */\n    var polymerase53 = function(sequence) {\n\n    };\n\n\n    /*************\n     High Level\n     *************/\n\n    /**\n     * @description performs digest given a marked or unmarked sequence and a single or array of enzyme, return fragments array ordered by length\n     * @param {string} sequence with or without marks already\n     * @param {Enzyme} enzyme\n     * @param {boolean} circularize default false (defined in makeCuts)\n     * @param {boolean} removeMarks default false\n     * @returns {*}\n     */\n    var digest = function(sequence, enzyme, circularize, removeMarks) {\n        if (!enzyme)\n            return 'no enzyme provided';\n\n        if (removeMarks)\n            sequence = removeMarks(sequence);\n\n        sequence = markCuts(sequence, enzyme);\n\n        var fragments =  makeCuts(sequence, circularize);\n\n        return _.sortBy(fragments, function(frag) {return -frag.length});\n    };\n\n\n\n    return {\n        //config\n        enzymes : enzymes,\n        cutMarks : cutMarks,\n\n        //utility\n        extendSequence : extendSequence,\n        createRegex : createRegex,\n        circularize : circularize,\n\n        //site basics\n        sitePresent : sitePresent,\n        identifySite : identifySite,\n        findMatches : findMatches,\n        findIndices : findIndices,\n\n        //find and mark\n        markSites : markSites,\n        markMatches : markMatches,\n        markCuts : markCuts,\n        removeCuts : removeCuts,\n        removeMatches : removeMatches,\n        removeMarks : removeMarks,\n        findOverhangs : findOverhangs,\n\n        //manipulation\n        makeCuts : makeCuts,\n        addRestrictionSite : addRestrictionSite,\n        swapoutSites : swapoutSites,\n\n        //quantification / sorting\n        sortFragments : sortFragments,\n        gelPurify : gelPurify,\n\n        //end pruning\n        removeOverhangs : removeOverhangs,\n        trimPastInternal : trimPastInternal,\n        exonuclease35 : exonuclease35,\n        exonuclease53 : exonuclease53,\n        polymerase53 : polymerase53,\n\n        //high-level\n        digest : digest\n\n    };\n\n}());"}
]