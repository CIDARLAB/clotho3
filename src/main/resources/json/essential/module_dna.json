[
{
    "schema":"Function",
    "id":"523e3b4cc2e6967acacb1721",
    "dependencies":["523e36e1c2e647abe23c1fa4"],
    "args":[{"type":"string","name":"sequence"}],
    "name":"DnaModuleTest",
    "code":"function(seq) { return DNA.revcomp(seq); };","language":"JAVASCRIPT",
    "tests":[{"args":["acgatcgatcg"],"output":{"value":"cgatcgatcgt","type":""}}]
},
{"schema": "Module", "name": "DNA", "language": "JAVASCRIPT", "id": "523e36e1c2e647abe23c1fa4", "code":"(function dna_module() {\n\n/*\n     iupac_nucleotides =\n     [ 'A', 'T', 'C', 'G', 'U',    Canonical bases\n     'B', 'V', 'D', 'H',           B = ^A, V= ^T, D= ^C, H= ^G\n     'S', 'W',                     Strong and Weak: GC vs. AT\n     'K', 'M',                     \"Keto\" and \"aMino\": GT vs. AC\n     'R', 'Y',                     \"puRine\" and \"pYrimidine\": AG vs. CT\n     'N' ]                         Wildcards: any N\n     */\n\n    var regexps = {},\n        monomers = {},\n        maps = {},\n        complements = {},\n        geneticCodes = {},\n        frequencies = {},\n        entropies = {},\n        weights = {};\n\n    regexps.letters = /[A-Z]/ig;\n    regexps.nucleotide = /[gautcGAUTC]/g;\n    regexps.dna = /[gatcGATC]/g;\n    regexps.rna = /[gaucGAUC]/g;\n    regexps.nucleotide_degnerate = /[gatucryswkmbdhvnxGATUCRYSWKMBDHVNX\\^_]/g;\n    regexps.protein = /[ACDEFGHIKLMNPQRSTVWYZacdefghiklmnpqrstvwyz\\*]/g;\n    regexps.protein_degenerate = /[ABCDEFGHIKLMNPQRSTVWYXZabcdefghiklmnpqrstvwyxz\\*]/g;\n\n    regexps.strip = {};\n    regexps.strip.dna = /[^gatcGATC]/g;\n    regexps.strip.nucleotide_degenerate = /[^gatucryswkmbdhvnxGATUCRYSWKMBDHVNX]/g;\n    regexps.strip.rna = /[^gaucGAUC]/g;\n    regexps.strip.protein = /[^ACDEFGHIKLMNPQRSTVWYZacdefghiklmnpqrstvwyz\\*]/g;\n    regexps.strip.protein_degenerate = /[^ABCDEFGHIKLMNPQRSTVWYXZabcdefghiklmnpqrstvwyxz\\*]/g;\n    regexps.strip.alignment = /[^\\.\\-]/g;\n    regexps.strip.non_letters = /[^A-Z]/ig;\n    regexps.strip.whitespace = /\\s/g;\n\n\n    monomers.dna = ('acgt').split('');\n    monomers.rna = ('acug').split('');\n    monomers.nucleotide = ('acgtu').split('');\n    monomers.nucleotide_degenerate = ('acgturyswkmbdhvnx').split('');\n    monomers.protein = ('ACDEFGHIKLMNPQRSTVWYZ*').split('');\n    monomers.protein_degnerate = ('ABCDEFGHIKLMNPQRSTVWXYZ*').split('');\n    //dna, rna, protein\n    monomers.all = (\"ABCDEFGHIKLMNPQRSTUVWXYZ*\").split('');\n\n\n    maps.nucleotide_degenerate = {\n        'A': 'A', 'B': '[CGTU]', 'C': 'C', 'D': '[AGTU]', 'G': 'G', 'H': '[ACTU]',\n        'K': '[GTU]', 'M': '[AC]', 'N': '[ACGTU]', 'R': '[AG]', 'S': '[CG]',\n        'T': 'T', 'U': 'U', 'V': '[ACG]', 'W': '[ATU]', 'Y': '[CTU]',\n        '.': '[ACGTU]', '-': '[ACGTU]'};\n    maps.nucleotide_undegenerate = {A: \"A\", C: \"C\", G: \"G\", T: \"T\", U: \"U\", '[ACGTU]': \"N\", '[ACG]': \"V\", '[ACTU]': \"H\", '[AC]': \"M\", '[AGTU]': \"D\", '[AG]': \"R\", '[ATU]': \"W\", '[CGTU]': \"B\", '[CG]': \"S\", '[CTU]': \"Y\", '[GTU]': \"K\"};\n    maps.dna_degenerate = {'A':'A','B':'[CGT]','C':'C','D':'[AGT]','G':'G',\n        'H':'[ACT]','K':'[GT]','M':'[AC]','N':'[ACGT]','R':'[AG]','S':'[CG]',\n        'T':'T','V':'[ACG]','W':'[AT]','Y':'[CT]','.':'[ACGT]','-':'[ACGT]'};\n    maps.rna_degenerate = {'A':'A','B':'[CGU]','C':'C','D':'[AGU]','G':'G',\n        'H':'[ACU]','K':'[GU]','M':'[AC]','N':'[ACGU]','R':'[AG]','S':'[CG]',\n        'U':'U','V':'[ACG]','W':'[AU]','Y':'[CU]','.':'[ACGU]','-':'[ACGU]'};\n\n    maps.amino_one_to_three = {\n        'A': 'Ala',\n        'B': 'Asx',\n        'C': 'Cys',\n        'D': 'Asp',\n        'E': 'Glu',\n        'F': 'Phe',\n        'G': 'Gly',\n        'H': 'His',\n        'I': 'Ile',\n        'K': 'Lys',\n        'L': 'Leu',\n        'M': 'Met',\n        'N': 'Asp',\n        'P': 'Pro',\n        'Q': 'Gln',\n        'R': 'Arg',\n        'S': 'Ser',\n        'T': 'Thr',\n        'V': 'Val',\n        'W': 'Trp',\n        'X': 'X',\n        'Y': 'Tyr',\n        'Z': 'Glx',\n        '*': '*'\n    };\n    maps.amino_one_to_full = {\n        'A': 'Alanine',\n        'B': '[Aspartic Acid or Asparagine]',\n        'C': 'Cysteine',\n        'D': 'Aspartic Acid',\n        'E': 'Glutamic Acid',\n        'F': 'Phenylalanine',\n        'G': 'Glycine',\n        'H': 'Histidine',\n        'I': 'Isoleucine',\n        'K': 'Lysine',\n        'L': 'Leucine',\n        'M': 'Methionine',\n        'N': 'Asparagine',\n        'P': 'Proline',\n        'Q': 'Glutamine',\n        'R': 'Arginine',\n        'S': 'Serine',\n        'T': 'Threonine',\n        'V': 'Valine',\n        'W': 'Tryptophan',\n        'X': 'Any',\n        'Y': 'Tyrosine',\n        'Z': '[Glutamine or Glutamic Acid]',\n        '*': 'Stop'\n    };\n\n\n    complements.dna = {\n        'a': 't',\n        'c': 'g',\n        'g': 'c',\n        't': 'a',\n        'A': 'T',\n        'C': 'G',\n        'G': 'C',\n        'T': 'A',\n        'r' : 'y',\n        'y' : 'r',\n        'R' : 'Y',\n        'Y' : 'R',\n        'k' : 'm',\n        'm' : 'k',\n        'K' : 'M',\n        'M' : 'K',\n        'b' : 'v',\n        'v' : 'b',\n        'B' : 'V',\n        'V' : 'B',\n        'd' : 'h',\n        'h' : 'd',\n        'D' : 'H',\n        'H' : 'D',\n        'n' : 'n',\n        'N' : 'N',\n        '^' : '_',\n        '_' : '^'\n    };\n\n    complements.rna = {\n        'a': 'u',\n        'c': 'g',\n        'g': 'c',\n        'u': 'a',\n        'A': 'U',\n        'C': 'G',\n        'G': 'C',\n        'U': 'A',\n        'r' : 'y',\n        'y' : 'r',\n        'R' : 'Y',\n        'Y' : 'R',\n        'k' : 'm',\n        'm' : 'k',\n        'K' : 'M',\n        'M' : 'K',\n        'b' : 'v',\n        'v' : 'b',\n        'B' : 'V',\n        'V' : 'B',\n        'd' : 'h',\n        'h' : 'd',\n        'D' : 'H',\n        'H' : 'D',\n        'n' : 'n',\n        'N' : 'N',\n        '^' : '_',\n        '_' : '^'\n    };\n    complements.transcribe = {\n        'a': 'u',\n        'c': 'g',\n        'g': 'c',\n        't': 'a',\n        'A': 'U',\n        'C': 'G',\n        'G': 'C',\n        'T': 'A'\n    };\n    complements.reverse_transcribe = {\n        'a': 't',\n        'c': 'g',\n        'g': 'c',\n        'u': 'a',\n        'A': 'T',\n        'C': 'G',\n        'G': 'C',\n        'U': 'A'\n    };\n    // standard genetic code\n    // see https://github.com/cathalgarvey/PySplicer/blob/master/pysplicer/translationtables.py for more\n    complements.translate = {\n        'uuu' : 'F',    'ucu' : 'S',    'uau' : 'Y',    'ugu' : 'C',\n        'uuc' : 'F',    'ucc' : 'S',    'uac' : 'Y',    'ugc' : 'C',\n        'uua' : 'L',    'uca' : 'S',    'uaa' : '*',    'uga' : '*',\n        'uug' : 'L',    'ucg' : 'S',    'uag' : '*',    'ugg' : 'W',\n\n        'cuu' : 'L',    'ccu' : 'P',    'cau' : 'H',    'cgu' : 'R',\n        'cuc' : 'L',    'ccc' : 'P',    'cac' : 'H',    'cgc' : 'R',\n        'cua' : 'L',    'cca' : 'P',    'caa' : 'Q',    'cga' : 'R',\n        'cug' : 'L',    'ccg' : 'P',    'cag' : 'Q',    'cgg' : 'R',\n\n        'auu' : 'I',    'acu' : 'T',    'aau' : 'N',    'agu' : 'S',\n        'auc' : 'I',    'acc' : 'T',    'aac' : 'N',    'agc' : 'S',\n        'aua' : 'I',    'aca' : 'T',    'aaa' : 'K',    'aga' : 'R',\n        'aug' : 'M',    'acg' : 'T',    'aag' : 'K',    'agg' : 'R',\n\n        'guu' : 'V',    'gcu' : 'A',    'gau' : 'D',    'ggu' : 'G',\n        'guc' : 'V',    'gcc' : 'A',    'gac' : 'D',    'ggc' : 'G',\n        'gua' : 'V',    'gca' : 'A',    'gaa' : 'E',    'gga' : 'G',\n        'gug' : 'V',    'gcg' : 'A',    'gag' : 'E',    'ggg' : 'G'\n    };\n    complements.reverse_translate = {\n        A : ['gcu', 'gcc', 'gca', 'gcg'],\n        C : ['ugu', 'ugc'],\n        D : ['gau', 'gac'],\n        E : ['gaa', 'gag'],\n        F : ['uuu', 'uuc'],\n        G : ['ggu', 'ggc', 'gga', 'ggg'],\n        H : ['cau', 'cac'],\n        I : ['auu', 'auc', 'aua'],\n        K : ['aaa', 'aag'],\n        L : ['uua', 'uug', 'cuu', 'cuc', 'cua', 'cug'],\n        M : ['aug'],\n        N : ['aau', 'aac'],\n        P : ['ccu', 'ccc', 'cca', 'ccg'],\n        Q : ['caa', 'cag'],\n        R : ['cgu', 'cgc', 'cga', 'cgg', 'aga', 'agg'],\n        S : ['ucu', 'ucc', 'uca', 'ucg', 'agu', 'agc'],\n        T : ['acu', 'acc', 'aca', 'acg'],\n        V : ['guu', 'guc', 'gua', 'gug'],\n        W : ['ugg'],\n        Y : ['uau', 'uac'],\n        '*' : ['uaa', 'uag', 'uga']\n    };\n    complements.reverse_translate_regexp = {\n        A : /gc[acgturyswkmbdhvn]/,\n        C : /[tu]g[ctuy]/,\n        D : /ga[tcuy]/,\n        E : /ga[agr]/,\n        F : /[tu][tu][tcuy]/,\n        G : /gg[acgturyswkmbdhvn]/,\n        H : /ca[tcuy]/,\n        I : /a[tu][atcuwmhy]/,\n        K : /aa[agr]/,\n        L : /c[tu][acgturyswkmbdhvn]|[tu][tu][agr]|[ctuy][tu][agr]/,\n        M : /a[tu]g/,\n        N : /aa[tucy]/,\n        P : /cc[acgturyswkmbdhvn]/,\n        Q : /ca[agr]/,\n        R : /cg[acgturyswkmbdhvn]|ag[agr]|[cam]g[agr]/,\n        S : /[tu]c[acgturyswkmbdhvn]|ag[ct]/,\n        T : /ac[acgturyswkmbdhvn]/,\n        V : /g[tu][acgturyswkmbdhvn]/,\n        W : /[tu]gg/,\n        Y : /[tu]a[ctuy]/,\n        '*' : /[tu]a[agr]|[tu]ga|[tu][agr]a/\n    };\n\n\n    //todo\n    //https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi?mode=c\n    geneticCodes.standard = {};\n\n\n\n    //todo\n    //see\n    frequencies.ecoli = {\n\n    };\n\n\n    //used in melting point calculations -- currently only DNA\n    //SantaLucia, J. (1998) Proc. Nat. Acad. Sci. USA 95, 1460.\n    entropies.ds_terminal = {\n        g : -2.8,\n        a : 4.1,\n        t : 4.1,\n        c : -2.8\n    };\n    entropies.dh_terminal = {\n        g : 0.1,\n        a : 2.3,\n        t : 2.3,\n        c : 0.1\n    };\n    entropies.ds = {\n        gg: -19.9, ag: -21.0, tg: -22.7, cg: -27.2,\n        ga: -22.2, aa: -22.2, ta: -21.3, ca: -22.7,\n        gt: -22.4, at: -20.4, tt: -22.2, ct: -21.0,\n        gc: -27.2, ac: -22.4, tc: -22.2, cc: -19.9\n    };\n    entropies.dh = {\n        gg : -8.0, ag : -7.8, tg : -8.5, cg : -10.6,\n        ga : -8.2, aa : -7.9, ta : -7.2, ca : -8.5,\n        gt : -8.4, at : -7.2, tt : -7.9, ct : -7.8,\n        gc : -10.6,ac : -8.4, tc : -8.2, cc : -8.0\n    };\n\n\n    //verify\n    //deoxy bases e.g. dAMP, dTTP etc. - no salt\n    weights.dna = {\n        'a' : 313.2,\n        't' : 304.2,\n        'c' : 289.2,\n        'g' : 329.2,\n        'u' : 290.2\n    };\n    //AMP, TMP etc. no salt\n    weights.rna = {\n        'a' : 329.2,\n        't' : 320.2,\n        'c' : 305.2,\n        'g' : 345.2,\n        'u' : 306.2\n    };\n\n\n\n    /**************\n    Basics\n    **************/\n\n    var lettersOnly = function (input) {\n        return input.replace(regexps.letters, '');\n    };\n\n    var dnaOnly = function (sequence, strict) {\n        var filter = strict ? regexps.strip.dna : regexps.strip.nucleotide_degenerate;\n        return sequence.replace(filter, '');\n    };\n\n    // use regexps.strip.<type> e.g. regexps.strip.dna\n    var verify = function(sequence, reg) {\n        return (sequence.search(reg) == -1)\n    };\n\n    //given a sequence (e.g. ACNT), return RegExp friendly version using given map (e.g. AC[ACGTU]T)\n    //note currently only nucleotides\n    var undegenerize = function(sequence, map) {\n        map = !!map ? map : maps.nucleotide_degenerate;\n        return sequence.replace(regexps.nucleotide_degenerate, function(m) {return map[m.toUpperCase()]});\n    };\n\n\n    /**************\n    Sequence manipulation\n    **************/\n\n    var reverse = function(sequence) {\n        return sequence.split(\"\").reverse().join(\"\")\n    };\n\n    var complement = function(sequence) {\n        return sequence.replace(regexps.nucleotide_degnerate, function(m) {return complements.dna[m] } );\n    };\n\n    var rna_to_dna = function (sequence) {\n        return sequence.replace(/[uU]/ig, function(m) {return {'u':'t', 'U':'T'}[m]});\n    };\n\n    var dna_to_rna = function (sequence) {\n        return sequence.replace(/[tT]/ig, function(m) {return {'t':'u', 'T':'U'}[m]});\n    };\n\n    var amino_one_to_three = function (sequence) {\n        var protein = [];\n        _.forEach(sequence.split(''), function (amino, ind) {protein.push( maps.amino_one_to_three[amino])});\n        return protein.join(' ');\n    };\n\n    var amino_one_to_full = function (sequence) {\n        var protein = [];\n        _.forEach(sequence.split(''), function (amino, ind) {protein.push (maps.amino_one_to_full[amino])});\n        return protein.join(' ');\n    };\n\n    var revcomp = function(sequence) {\n        return reverse(complement(sequence));\n    };\n\n    var randomSequence = function (length, units) {\n        units = units || monomers.dna;\n        if (typeof length == 'string')\n            length = length.length;\n\n        if (length == 0) return '';\n\n        var sequenceArray = [],\n            tempNum = 0,\n            tempChar = \"\";\n        for (var j = 0; j < (length); j++)\t{\n            tempNum = Math.floor(Math.random() * units.length);\n            tempChar = units[tempNum];\n            sequenceArray.push(tempChar);\n        }\n        return sequenceArray.join(\"\");\n    };\n\n    var shuffleSequence = function (sequence) {\n        return _.shuffle(sequence.split('')).join('');\n    };\n\n    //adds a space every three characters\n    var codonSpace = function (sequence) {\n        return sequence.match(/.{1,3}/g).join(\" \");\n    };\n\n    /**************\n     Central Dogma\n     **************/\n\n    var transcribe = function (sequence) {\n        return sequence.replace(regexps.dna, function(m) { return complements.transcribe[m] });\n    };\n\n    var reverseTranscribe = function (sequence) {\n        return sequence.replace(regexps.rna, function(m) { return complements.reverse_transcribe[m] });\n    };\n\n    /**\n     * @name DNA.translate\n     * @param {string} sequence RNA Sequence to be translated. DNA will be converted (not transcribed) to RNA.\n     * @param {number} forceOffset Force an offset of 0,1,2 bases as reading frame\n     * @returns {string} Polypeptide translated\n     */\n    var translate = function (sequence, forceOffset) {\n\n        //checks\n        if (verify(sequence, regexps.strip.dna)) {\n            sequence = dna_to_rna(sequence);\n        }\n        var seqlen = sequence.length;\n        if (seqlen < 3) return '';\n        sequence = sequence.toLowerCase();\n\n\n        var offset = (!!forceOffset) ? forceOffset : probableORF(sequence),\n            polypep = \"\";\n\n        sequence = sequence.substring(offset);\n\n        if ((seqlen % 3) != 0)\n            sequence = sequence.substring(0, (Math.floor(seqlen / 3) * 3));\n\n        for (var i = 0; i < sequence.length; i = i+3) {\n            polypep = polypep + complements.translate[sequence.substr(i, 3)];\n        }\n\n        return polypep;\n    };\n\n    var reverseTranslate = function (sequence, codonFreq) {\n        if (!sequence) return;\n\n        var dumb = (!codonFreq || _.isUndefined(codonFreq) || codonFreq == null) ? true : false;\n        var rna = '';\n\n        for(var seq = sequence.split(''), i = 0; i < seq.length; i++) {\n            var options = (complements.reverse_translate[seq[i]]);\n            if (dumb) {\n                rna = rna + options[Math.floor(Math.random()*options.length)]\n            } else {\n                //future implement non-dumb version once have frequency table...\n                rna = rna + options[0]\n            }\n        }\n\n        return rna;\n    };\n\n\n    /**\n     * @description Determines fragments for each ORF for a given sequence\n     * @param sequence\n     * @returns {boolean|object} false if no proteins (atg...stop), otherwise object in the following form, with frags descending by length:\n     {\n        sequence : <input sequence>,\n        frags : [\n            {\n                match : <matched seq (from atg ... tag|tga|taa)>\n                index : <match index>\n                length : <dna seq length>\n            }\n            ...\n        ],\n        longest : <length of longest putative protein>\n     }\n\n     */\n    var calcORFs = function(sequence) {\n        var frames = {},\n            orfReg = new RegExp('((atg)(.+?)(ta[agr]|tga|t[agr]a))', 'gi');\n\n        //no real proteins\n        if (!orfReg.test(sequence)) return false;\n\n        for (var i = 0; i < 3; i++) {\n            frames[i] = {};\n            frames[i].sequence = sequence;\n            frames[i].frags = [];\n\n            var match;\n            while ((match = orfReg.exec(sequence)) != null) {\n                frames[i].frags.push({\n                    match : match[0],\n                    index : match.index,\n                    length : match[0].length\n                })\n            }\n            frames[i].frags.sort(function(a, b){ return b.length - a.length; });\n            frames[i].longest = frames[i].frags[0].length;\n        }\n\n        return frames;\n    };\n\n    /**\n     * @description Returns the offset for the longest ORF\n     * @param sequence\n     * @returns {number}\n     */\n    var probableORF = function (sequence) {\n        var offset = 0,\n            longest = 0;\n\n        var frames = calcORFs(sequence);\n\n        //no proteins, retruned false\n        if (!frames) return 0;\n\n        for (var i = 0; i < frames.length; i++) {\n            if (longest < frames[i].longest) {\n                longest = frames[i].longest;\n                offset = i;\n            }\n        }\n        //future - check codon frequency\n        //future - alignment to database e.g. blast or something\n\n        return offset;\n    };\n\n\n    /**************\n     Quantification\n     **************/\n\n    /**\n     * @description Returns number of occurances of a given base or oligo in a sequence. Handles overlaps.\n     * @example occuranceCount('aataa', 'a') -> 4\n     * @example occuranceCount('aaaa', 'aa') -> 3\n     * @param sequence\n     * @param {String} oligo Single-letter base or oligo to look for\n     * @param {boolean=} convertDegenerate Whether degenerate nucleotides should be converted to standard [ACGTU]. Default is false\n     * @returns {Number} Number of matches found, 0 if none found\n     */\n    var occuranceCount = function(sequence, oligo, convertDegenerate) {\n        var search = !!convertDegenerate ? undegenerize(oligo) : oligo;\n        var matches = sequence.match(new RegExp('(?=(' + search + '))', 'gi'));\n        return !!matches ? matches.length : 0;\n    };\n\n    /**\n     * @description Get a count of each monomer in a sequence\n     * @param {string} sequence\n     * @param {object=} units Array or Object of monomers to search e.g. monomers.nucleotides\n     * @returns {object} object whose keys are monomers, and values are number of occurances\n     */\n    var monomer_count = function (sequence, units) {\n        units = (typeof units != 'undefined' ? units : monomers.all);\n        var counts = {};\n        _.forEach(units, function(unit) {\n            counts[unit] = occuranceCount(sequence, unit);\n        });\n        return counts;\n    };\n\n    /**\n     * @description Determines number of occurances of neighboring nucleotides, e.g. 'ac' -> 4\n     * @note Currently only DNA\n     * @param sequence\n     * @param minCount\n     * @param units\n     * @returns {object}\n     */\n    var neighbor_count = function (sequence, minCount, units) {\n        units = (typeof units != 'undefined') ? units : monomers.dna;\n        minCount = (typeof minCount != 'undefined') ? minCount : 0;\n        var counts = {};\n        _.forEach(units, function (u1) {\n            _.forEach(units, function (u2) {\n                var combo = u1 + u2,\n                    count = occuranceCount(sequence, combo);\n                if (count >= minCount)\n                    counts[combo] = count;\n            });\n        });\n        return counts;\n    };\n\n    /**\n     * @description Calculates GC content of non-degenerate nucleotide sequence\n     * @note Doesn't work for degenerate sequences\n     * @param {string} dna Sequence of non-degenerate DNA or RNA\n     * @returns {number} fraction of GC in whole sequence\n     */\n    var GC_content = function(dna) {\n        var full = dna.length,\n            gc = (dna.replace(/[^GCS]/gi, '')).length;\n\n        return (gc / full);\n    };\n\n\n    var gibbs = function(sequence) {\n        var dg = 0,\n            dh = 0,\n            ds = 0,\n            counts = monomer_count(sequence, monomers.nucleotide),\n            neighbors = neighbor_count(sequence, monomers.nucleotide),\n            gc = GC_content(sequence);\n\n        //todo calc: rlnk, deltaG, H, S @ standard cond\n\n        return [dg, dh, ds]\n\n    };\n\n\n    var melting_temp_basic = function (sequence) {\n        if (sequence.length < 14) {\n            var counts = monomer_count(sequence, monomers.dna);\n            return (counts['a']+counts['t'])*2 + (counts['c'] + counts['g'])*4\n        }\n\n        //64.9°C + 41°C x (number of G’s and C’s in the oligo – 16.4)/N\n        return 64.9+41*(GC_content(sequence)*sequence.length - 16.4)/sequence.length;\n    };\n\n    //verify\n    var melting_temp_saltAdjusted = function (sequence, saltConc) {\n        saltConc = !!saltConc ? saltConc : 0.050;\n\n        var counts = monomer_count(sequence, monomers.dna);\n\n        if (sequence.length < 14) {\n            return (counts['a']+counts['t'])*2 + (counts['c'] + counts['g'])*4 - 16.6*(Math.log(0.050) / Math.log(10)) + (16.6 * (Math.log(saltConc) / Math.log(10)))\n        } else if (sequence.length < 50) {\n            return 100.5 + (41 * (counts['g']+counts['c'])/(counts['a']+counts['t']+counts['g']+counts['c'])) - (820/(counts['a']+counts['t']+counts['g']+counts['c'])) + (16.6 * (Math.log(saltConc) / Math.log(10)))\n        } else {\n            return 81.5 + (41 * (counts['g']+counts['c'])/(counts['a']+counts['t']+counts['g']+counts['c'])) - (500/(counts['a']+counts['t']+counts['g']+counts['c'])) + (16.6 * (Math.log(saltConc) / Math.log(10)))\n        }\n    };\n\n    /**\n     * @description More complex melting temperature calculation for a given sequence. The most sophisticated Tm calculations take into account the exact sequence and base stacking parameters, not just the base composition.\n     * Tm = ((1000* dh)/(ds+(R * Math.log(primer concentration))))-273.15;\n     * @param {string} sequence ONLY CANONICAL DNA BASES (A,C,G,T)\n     * @param {object} conc Concentrations with parameters 'dna' 'salt' and 'mg' all Molar\n     */\n\n    //todo - account for buffers, see NEB site\n    //https://www.neb.com/tools-and-resources/interactive-tools/tm-calculator\n    var melting_temp = function (sequence, conc) {\n        if (sequence.length < 1) return;\n\n        if ((regexps.strip.dna).exec(sequence)) {\n            console.log('contains non-dna letters... aborting melting temp calc');\n            return;\n        }\n\n        sequence = sequence.toLowerCase();\n\n        conc = typeof conc != 'undefined' ? conc : {};\n        conc.dna = typeof conc.dna != 'undefined' ? conc.dna : 0.0000002;   // Molar (200nM)\n        conc.salt = typeof conc.salt != 'undefined' ? conc.salt : 0.050;    // Molar (50mM)\n        conc.mg = typeof conc.mg != 'undefined' ? conc.mg : 0.0015;         // Molar (2.5mM)\n        //conc.ph = typeof conc.ph != 'undefined' ? conc.ph : 7.0;          //pH - NOT USED CURRENTLY\n\n        var R = 1.987; //universal gas constant in Cal/degrees C * mol\n        var ds = 0;    //cal/Kelvin/mol\n        var dh = 0;    //kcal/mol\n\n        // salt correction\n        var correctedSalt = conc.salt + conc.mg * 140; //adjust for greater stabilizing effects of Mg compared to Na or K. See von Ahsen et al 1999\n        ds = ds + 0.368 * (sequence.length - 1) * Math.log(correctedSalt); //from von Ahsen et al 1999\n\n        // terminal corrections\n        ds = ds + entropies.ds_terminal[sequence.charAt(0)] + entropies.ds_terminal[sequence.charAt(sequence.length - 1)];\n        dh = dh + entropies.dh_terminal[sequence.charAt(0)] + entropies.dh_terminal[sequence.charAt(sequence.length - 1)];\n\n        //nearest neighbors\n        var neighbors = neighbor_count(sequence);\n        _.forEach(neighbors, function (num, pair) {\n            ds = ds + (entropies.ds[pair] * num);\n            dh = dh + (entropies.dh[pair] * num);\n        });\n\n        return ((1000 * dh) / (ds + (R * Math.log(conc.dna / 2)))) - 273.15;\n\n    };\n\n    //todo - handle proteins, verify correct\n    var molecular_weight = function(sequence) {\n        if (!sequence || sequence.length < 1) return;\n\n        var type = verify(sequence, regexps.strip.dna) ? 'dna' : 'rna',\n            nucs = monomers.nucleotide,\n            weight = 0,\n            counts = monomer_count(sequence, nucs);\n\n        _.forEach(nucs, function(nuc) {\n            weight = weight + (weights[type][nuc] * counts[nuc]);\n        });\n\n        // future - more rigorous\n        //triphospate --- could substract 61.96 instead to remove phospate and add hydroxyl, and subsequently can add 79.0 for restriction-enzyme cut DNA which leaves 5' monophospate\n        weight = weight + 159.0;\n\n        return weight;\n    };\n\n\n    var selfComplimentarity = function (rna) {\n        //todo calculate 2° structure\n    };\n\n\n\n    /**************\n     Species Specific\n     **************/\n\n    //todo\n    var codonOptimize = function(sequence, species) {\n\n    };\n\n    //todo\n    var findSilentSites = function(sequence, species) {\n\n    };\n\n\n\n    /**************\n     Checks\n     **************/\n\n    /**\n     * @description\n     * @param unit\n     * @param repeat\n     * @returns {string}\n     */\n    var createRun = function(unit, repeat) {\n        return new Array(+repeat + 1).join(unit);\n    };\n\n    /**\n     * @description Look for double repeats like 'acacacac'\n     * @note currently DNA only\n     * @param oligo\n     * @param max\n     */\n    var verifyRepeats = function(oligo, max) {\n        var flag = true;\n        max = typeof max != 'undefined' ? max : 4;\n        monomers = typeof monomers != 'undefined' ? monomers : monomers.nucleotide;\n\n        //first, neighbor count for possible problems\n        var counts = neighbor_count(oligo, max);\n\n        //then go through neighbors\n        for (var index in counts) {\n            if (!counts.hasOwnProperty(index))\n                break;\n            if ((new RegExp(createRun(index, max), 'ig')).test(oligo))\n                flag = false;\n        }\n\n        return flag;\n    };\n\n    /**\n     * @description checks for runs of the same nucleotide (e.g. 'aaaa')\n     * @param oligo\n     * @param max\n     * @param monomers\n     * @returns {boolean}\n     */\n    var verifyRuns = function(oligo, max) {\n        var flag = true;\n        max = typeof max != 'undefined' ? max : 4;\n        monomers = monomers.nucleotide;\n\n        for (var i = 0; i < monomers.length; i++) {\n            if ( occuranceCount( oligo, createRun(monomers[i], max) ) )\n                flag = false;\n        }\n\n        return flag;\n    };\n\n    var verifyMeltingTemps = function(primers) {\n        var max = 0, min = 0;\n        for (var i = 0; i < primers.length; i++) {\n            var temp = melting_temp(primers[i]);\n            max = (max > temp) ? max : temp;\n            min = (min < temp) ? min : temp;\n        }\n\n        if (max == 0 || min == 0) {}\n\n        return ((max - min) <= 6);\n    };\n\n\n\n    /****************\n     PARSING -- future\n     ****************/\n\n    var parseFASTA = {};\n\n    var parseEMBL = {};\n\n    var parseGenbank = {};\n\n    var outputFASTA = {};\n\n    var outputEMBL = {};\n\n    var outputGenbank = {};\n\n\n    return {\n        //config, info\n        regexps: regexps,\n        monomers : monomers,\n        maps : maps,\n        complements : complements,\n        geneticCodes : geneticCodes,\n        frequencies : frequencies,\n        weights : weights,\n\n        //utility\n        lettersOnly : lettersOnly,\n        dnaOnly : dnaOnly,\n        verify : verify,\n        undegenerize : undegenerize,\n\n        //manipulation\n        reverse : reverse,\n        complement : complement,\n        rna_to_dna : rna_to_dna,\n        dna_to_rna : dna_to_rna,\n        amino_one_to_three : amino_one_to_three,\n        amino_one_to_full : amino_one_to_full,\n        revcomp : revcomp,\n        randomSequence : randomSequence,\n        shuffleSequence : shuffleSequence,\n        codonSpace : codonSpace,\n\n        //central dogma\n        transcribe : transcribe,\n        reverseTranscribe : reverseTranscribe,\n        translate : translate,\n        reverseTranslate : reverseTranslate,\n        calcORFs : calcORFs,\n        probableORF : probableORF,\n\n        //quantification\n        occuranceCount : occuranceCount,\n        monomer_count : monomer_count,\n        neighbor_count : neighbor_count,\n        GC_content : GC_content,\n        gibbs : gibbs,\n        melting_temp_basic : melting_temp_basic,\n        melting_temp_saltAdjusted : melting_temp_saltAdjusted,\n        melting_temp : melting_temp,\n        molecular_weight : molecular_weight,\n\n        //cehcks\n        createRun : createRun,\n        verifyRepeats : verifyRepeats,\n        verifyRuns : verifyRuns,\n        verifyMeltingTemps : verifyMeltingTemps\n    };\n\n}());" }
]